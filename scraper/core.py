"""Fill in a module description here"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['IGNORE_EXT', 'HTTP_URL_PATTERN', 'ALLOWED_EXT_CONTENT_TYPS', 'valid_href', 'hydrate_links', 'get_fn_from_url']

# %% ../nbs/00_core.ipynb 2
import re
from fastcore.all import *
from urllib.parse import urlparse, urlencode, quote_plus, unquote
import requests

# %% ../nbs/00_core.ipynb 3
IGNORE_EXT = [
    ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".tiff", ".tif", ".webp",  # Image Files
    ".mp3", ".wav", ".aac", ".flac", ".mp4", ".avi", ".mov", ".mkv", ".webm",  # Audio and Video Files
    ".zip", ".rar", ".tar", ".gz", ".7z",  # Archive Files
    ".css", ".js", ".json", ".xml", ".yaml", ".yml", ".md",  # Web and Code Files
    ".sql", ".sqlite", ".db", ".bak",  # Database and Backup Files
    ".iso", ".epub", ".chm", ".dmg", ".apk", ".exe", ".bin",  # Miscellaneous Files
    ".py", ".java", ".cpp", ".go", ".rb", ".sh",  # Code and Script Files
]

def valid_href(href:str):
    """
    Checks if the provided `href` should be ignored based on a set of conditions.
    Returns True if the href matches any ignore condition, otherwise False.
    """
    if href is None:
        return False
    ignore_conditions = [
        lambda x: x == "" or x == "#" ,
        lambda x: x.startswith(("ftp:", "irc:", "mailto:", "tel:", "javascript:", "app://", "#", ".#")),
        lambda x: any(i in x for i in ["private","subscribe","paywall","login"]),
        lambda x: any(x.endswith(i) for i in IGNORE_EXT)
        ]
    
    href = href.lower()
    for fn in ignore_conditions:
        if fn(href):
            return False

    return True

# %% ../nbs/00_core.ipynb 5
HTTP_URL_PATTERN = r'^http[s]*://.+'
def hydrate_links(local_domain, url):
    """Converts relative URLs to absolute; returns None for external links."""
    url = unquote(url)
    if '#' in url:
        return None
        
    clean_link = None
    
    if re.search(HTTP_URL_PATTERN, url):
        url_obj = urlparse(url)
        if url_obj.netloc == local_domain:
                clean_link = url

    else:
        if url.startswith("/"):
            url = url[1:]
        clean_link = "https://" + local_domain + "/" + url

    if clean_link is not None:
        if clean_link.endswith("/#"):
            clean_link = clean_link[:-2] 
        if clean_link.endswith("/") or  clean_link.endswith("#"):
            clean_link = clean_link[:-1]

    return clean_link 

# %% ../nbs/00_core.ipynb 8
ALLOWED_EXT_CONTENT_TYPS = {
    ".pdf": "application/pdf",
    ".doc": "application/msword",
    ".docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ".odt": "application/vnd.oasis.opendocument.text",
    ".xls": "application/vnd.ms-excel",
    ".xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    ".ppt": "application/vnd.ms-powerpoint",
    ".pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    ".txt": "text/plain",
    ".csv": "text/csv",
    ".html": "text/html",
}
def get_fn_from_url(url: str):
    """
    Return the file name from the URL.
    If URL ends with .pdf, .doc, .docx, .html etc, return path.<extension>.
    Else return path_params_query.html.
    """

    parsed_url = urlparse(unquote(url.lower()))
    
    path = parsed_url.path
    path += f"/{parsed_url.params}" if parsed_url.params else ""
    path += f"/{parsed_url.query}" if parsed_url.query else ""
    
    path = re.sub(r"[\/=\?\s]", "_", path)
    
    if any(path.endswith(ext) for ext in ALLOWED_EXT_CONTENT_TYPS.keys()):
        return path

    # Default case: return path with .html extension
    return path + '.html'
